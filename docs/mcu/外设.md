# SPI
#SPI总线

### SPI工作模式
根据时钟极性（CPOL）及相位（CPHA）不同，SPI有四种工作模式。
* 时钟极性(CPOL)定义了时钟SCK空闲状态电平：
CPOL=0：时钟SCK空闲时为低电平
CPOL=1：时钟SCK空闲时为高电平
* 时钟相位(CPHA)定义数据的采集时间。
CPHA=0：在时钟SCK的第一个跳变沿（上升沿或下降沿）进行数据采样。
CPHA=1：在时钟SCK的第二个跳变沿（上升沿或下降沿）进行数据采样。
![Pasted image 20230423165108|650](https://raw.githubusercontent.com/24849748/PicBed/main/ob/Pasted%20image%2020230423165108-%7BYYmmhhss%7D.png)

### STM32F1 SPI相关寄存器
* SPI_CR1控制寄存器1，配置SPI工作参数
	* 方向：全双工/双线双向
	* 数据帧：8bit/16bit
	* NSS模式
	* 波特率：最高速率，fPCLK/n，如72M/n=36
	* CPOL/CPHA
* SPI_SR状态寄存器，查询当前传输状态 `TXE、RXNE`
	* 发送缓冲TXE = 0：非空，1：空
	* 接收缓冲RXNE = 0：空，1：非空
* SPI_DR数据寄存器，存放待发送和接收的数据，有两个缓冲区

* 修改SPI速度：
	1. `__HAL_SPI_DISABLE()`，
	2. 修改SPI->CR1寄存器
	3. `_HAL_SPI_ENABLE()`


#### 查看SPI发送/接收完成？
查看寄存器`SPI_SR`


# IIC
#IIC总线

全称Inter-integrated Circuit，一般采样**一主多从**模式

IIC硬件引脚有SCL、SDA，开漏输出，空闲时高电平，因此需要外部上拉

IIC速度：标称速度100kbps，高速400kbps，特高速1.2Mbps，其余速度只能通过软件模拟实现

## IIC数据帧（上读下写）
![1-IIC读写数据帧-20230529|550](https://raw.githubusercontent.com/24849748/PicBed/main/ob/202306031505142.png)
* addr：设备地址码为**7位**
* 设备地址后面跟随1位读写操作指示：0写，1读
* ACK应答信号：0收到，1从机忙、没有收到或读取完成

![[../addon/IIC起始停止信号-20230529.png|500]]
* 起始位：起始信号必须是SCL在高电平期间，SDA产生下降动作
* 停止位：停止信号必须是SCL在高电平期间，SDA产生上升动作

![[../addon/IIC逻辑10-20230529.png|500]]
* 当SCL是高电平时，SDA数据线的电平就是逻辑电平


## 深入理解

**IIC的字节控制**
IC的字节控制每传输8个位，就会留下一个位用于监听，这个位由接受数据的芯片返回“是否应答成功”。
写数据到从机时，从机应答；由从机读数据时，主机应答。
如果应答成功，传输将继续，未及时返回应答将重置通信进度，下一次传输将从头开始。所以你会看到一个奇葩要求，由从机发送数据到主机之后，主机要在最后一个字节回复“应答失败”。
因为从机芯片的C控制器是保存内存指针的，根据不同芯片工作模式，会出现“每次传输下一内存地址”或者“每次传输固定内存地址”其中一种工作模式，如果读了最后一个字节还是“应答成功”，从机就不会重置内存指针，认定下一个写进去的字节不是地址而是数据。

**谁主谁从？**
一般来说，谁产生SCL谁就是主机，起止位也是主机产生

## 多主机仲裁

当IIC工作在“多主多从”时，需要加入仲裁机制，==挖坑==

