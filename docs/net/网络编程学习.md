


## 专有名词

### 惊群效应
linux2.6之前，socket listen()会唤醒等待队列里所有进程，但最后其实只有一个进程会处理这个连接请求，其他进程又重新进入休眠，这些被唤醒了又无事可做最后只能重新回去休眠的进程会消耗一定的资源。
linux2.6之后这个问题被修复了。

### TCP三次握手

### 半连接&全连接
半连接：服务端握手次数还没到三次，用半连接队列（hash表）存放
全连接：完成三次握手的连接，用全连接队列（链表）存放


## socket
套接字，“一套用于网络连接的数字”

流程：
1. 双方都 `socket()` 得到 `fd` 句柄
2. 对于服务端依次执行 `bind()`、`listen()`、`accept()`
3. 等客户端执行 `connect()` ，建立连接，此时会发生TCP三次握手
4. 建立连接后，客户端可以`send()`、服务端可以`recv()` ，反之可以


### sock数据结构

![image.png|380](https://raw.githubusercontent.com/24849748/PicBed/main/ob/202309111148313.png)

* sock：最基础的数据结构，任何协议都有可能用到的收发数据缓冲区
* inet_sock：网络传输功能，在sock的基础上加入TTL、端口、IP地址、Unix domain socket等
* inet_connection_sock：面向连接的sock，在inet_sock基础上加入面向连接的协议里相关字段，比如==accept队列==、数据包分片大小、握手失败重试次数等
* tcp_sock：TCP协议专用的sock结构，在inet_connection_sock基础上加入tcp特有的滑动窗口、拥塞避免等功能


![image.png|430](https://raw.githubusercontent.com/24849748/PicBed/main/ob/202309121014959.png)


### 数据传输

#### 客户端：
**发送**：`send()`将数据放在==发送缓冲区==，然后结束流程

**接收**：接收数据时，内核将数据放在接收缓冲区，等待应用程序执行`recv()`

那怎么通知应用程序呢？==等待队列==
执行`recv()`时
* 如果由数据，那正好取走结束
* 如果没数据，应用程序将自己的**进程**信息注册到sock里的等待队列里，然后进程休眠。如果有数据从服务器发来，数据从远端发来，数据进入接收缓冲区，内核去除**等待队列**里的进程，唤醒进程来获取数据。

#### 服务端
服务端执行`listen()`的时候，有那么多数据到一个socket怎么区分多个客户端？
客户端发来的数据包上会有一个**四元组**
* 源IP地址和端口
* 目的IP地址和端口



