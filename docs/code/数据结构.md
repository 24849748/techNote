# 链表

## linux 内核链表学习

==既然链表不能包含万事万物，那么就让万事万物来包含链表。==

```c
// 初始化
pt_inline void pt_list_init(pt_list_t *l)
{
    l->next = l->prev = l;
}



// 在l节点后面插入新节点
pt_inline void pt_list_insert_after(pt_list_t *l, pt_list_t *n)
{
    l->next->prev = n;
    n->next = l->next;

    l->next = n;
    n->prev = l;
}

// 在l节点前面插入新节点
pt_inline void pt_list_insert_before(pt_list_t *l, pt_list_t *n)
{
    l->prev->next = n;
    n->prev = l->prev;

    l->prev = n;
    n->next = l;
}



```





### 单链表

### 双链表


## 单链表
### 合并两个有序链表（leetcode 21）
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)
{
    struct ListNode dummy = ListNode(-1);   // 创建新头节点
    ListNode *prev = &dummy;
    struct ListNode *p, *q;
    while(p != NULL && q != NULL)
    {
        if(p->val < q->val)
        {
            prev->next = p;
            p = p->next;
        }else
        {
            prev->next = q;
            q = q->next;
        }
        prev = prev->next;
    }
    return dummy.next;
}
```
时间复杂度：O(n+m)
空间复杂度：O(1)
![[Pasted image 20230424114740.png]]

## 数组环形队列

	设模拟环形队列的线性表长度是N，队头指针为head，队尾指针为
	tail，则每增加一条记录，就可以用以下方法计算新的队尾指针：  
	tail = (tail + 1) % N

![[Pasted image 20230428102037.png]]

1. 队头队尾应该存储数组下标而不是数组指针
2. 上图`tail`本质是地址，`*tail`是元素，
3. 上面公式`tail = (tail+1)%N`本质上是对元素地址+1，再N取余


# 动态数组

# 二叉树

# 哈希表

# 红黑树

# 平衡树


