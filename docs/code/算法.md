
## 十大排序算法

| 算法     | 平均复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |
| -------- | ---------- | -------- | -------- | ---------- | -------- | ------ |
| 冒泡排序 | O(n2) | O(n) | O(n2) | O(1) | In-place | 稳定 |
| 选择排序 |            |          |          |            |          |        |
| 插入排序 |            |          |          |            |          |        |
| 希尔排序 |            |          |          |            |          |        |
| 归并排序 |            |          |          |            |          |        |
| 堆排序   |            |          |          |            |          |        |
| 计数排序 |            |          |          |            |          |        |
| 桶排序   |            |          |          |            |          |        |
| 基数排序 |            |          |          |            |          |        |


1. [[算法#插入排序Insertion Sort|插入排序]]
2. [[算法#快速排序|快速排序]]
3. [[算法#|归并排序]]


### 插入排序Insertion Sort
基于数组插入操作的排序算法，选择待排序的元素作为基准 `base` ，将 `base` 与左侧已排序的元素逐一比较大小，并插入到正确位置

取未排序区间中的某个元素为基准数 `base`，将 `base` 与其左侧已排序区间元素依次对比大小，并"插入"到正确位置

#### 算法流程
1. 选数组第二个元素作为 `base` 
	1. 与上一个元素 j 作比较，大了就插入到前面
	2. 继续与上一个元素j做比较，循环比较条件 `(j>0 && arr[j]>base)`
2. `base` 为数组最后一个元素时 `(i<len)` ，排序完成
![[Pasted image 20230425111325.png|380]]

#### 算法特性
时间复杂度：O(n2)
空间复杂度：O(1)
在插入过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序，因此是“稳定排序”。

#### 优劣势
* 与冒泡排序比，冒泡需要借助临时变量，涉及3个单元操作，插入排序是基于元素赋值，仅需要1个单元操作
* 插入开销约为冒泡的三分之一
* 应用：
	* 对于短数组，使用插入排序
	* 对于长数组，采用基于分治思想的排序算法，如快速排序



### 快速排序


### 归并排序


## Leetcode刷题

### 415.字符串相加

```c
char * addStrings(char * num1, char * num2){
    int num1_len = strlen(num1)-1;
    int num2_len = strlen(num2)-1;
    char * ret_str = (char *)malloc(sizeof(char) * (((num1_len > num2_len)?num1_len:num2_len)+3));
    int add = 0, len = 0;
    
    while(num1_len >= 0 || num2_len >= 0 || add != 0)
    {
        int x = num1_len >= 0 ? num1[num1_len] - '0' : 0;
        int y = num2_len >= 0 ? num2[num2_len] - '0' : 0;
        int result = x + y + add;
        ret_str[len++] = '0' + result % 10;
        add = result/10;
        num1_len--;
        num2_len--;
    }
    // 计算为结果需要反转过来
    for(int i = 0; 2*i < len; i++)
    {
        int t = ret_str[i];
        ret_str[i] = ret_str[len-i-1];
        ret_str[len-i-1] = t;
    }
    ret_str[len++] = '\0';
    return ret_str;
}
```

### 20.有效括号
[判断有效括号](https://leetcode.cn/problems/valid-parentheses/)
```c
// 题意理解有出入，按我的理解执行结果正确
bool isValid(char * s){
    uint32_t slen = strlen(s);
    char *p = s;
    if(slen > 1000 || (slen % 2 == 1))    // 长度大于题目范围或者是奇数，都不符合要求
    {
        return false;
    }
  
    while(strlen(p) >= 2)    // 剩余长度大于等于2
    {
        if((*p == '(' && *(p+1) == ')') || (*p == '[' && *(p+1) == ']') || (*p == '{' && *(p+1) == '}'))
        {
            p += 2;
        }
        else
        {
            return false;
        }
    }
    return true;
}
```

```c
// 使用栈判断，包括这种情况({[]})
char c_compare(char c)
{
    if(c == '(') return ')';
    if(c == '{') return '}';
    if(c == '[') return ']';
    return 0;
}

bool isValid(char * s){
    int slen = strlen(s);
    char *p = s;
    if(slen > 1000 || (slen % 2 == 1))
    {
        return false;
    }


    int stack[slen+1];
    int top = 0;
    for(int i = 0; i < slen; i++)
    {
        char c = c_compare(s[i]);
        if(c)
        {
            if((top == 0) || (stack[top-1] ! = c))
            {
                return false;
            }
            top--;
        }
        else
        {
            stack[top++] = s[i];
        }
    }
  
    return (top==0) ? true : false;
}
```
