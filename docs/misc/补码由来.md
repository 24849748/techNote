---
title: 补码由来
date: 2024-11-24 01:12:01
# description: 
# mermaid: true
categories:
  - misc
tags:
  - 补码
published: false
---

补码作用：将减法转成加法，最高位为符号位，**0 正 1 负**

* 正数的补码等于原码
    * 如 5 `0101` 的补码为 `0101` 
* 负数的补码等于反码+1
    * 如求 -2 的补码
        * 转为原码等于 `1010`
        * 符号位不变，其余按位取反得 `1101`
        * +1 得补码 `1110`
* 

”负数的补码等于反码+1“ 只是补码的求法，不是定义、
补码的思想来源于**时钟、经纬度**
比如，时钟中，8+2=10 与 8-10=10 结果都一样
因为最终结果都一样，所以 8-10 就可以转换成 8+2 来运算

2 的由来：==模-10==
这里模就是 12 点

![Pasted image 20230523102907](https://raw.githubusercontent.com/24849748/PicBed/main/ob/202306091022192.png)

举例：`5-2`
1. 2（010）的补码（101 + 1）就是-2（110）  //  补码为反码+1，110 就是 6
2. 那么 `5-2` 就变成 `5+6` ，也就是 `5+(8-2)`
3. 计算机只看这三位，所以最终结果就是 3（101 + 110 = 011）

这里 8 是模，那么模 8 是怎么来的？

1. 我们知道，原码 + 反码 = 最大值全 1 `010 + 101 = 111` 
2. 那么如果要求反码，就可以用最大值-原码 `111 - 010`
3. 而补码又是反码+1 `111 - 010 + 1`
4. 变换一下 `111 + 1 - 010`
5. `111 + 1` 就是 8，所以就是 8 - 2

模等于最大值+1，如：
时钟上显示的最大数是 11 点，模就是 12 点
3bit 的数，模是 111+1；5bit 的模是 11111+1
