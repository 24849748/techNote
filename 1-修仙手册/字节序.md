对于多个字节组成的整数，在内存中有两种存储方法：
* ==低==字节存储在内存==起始地址==，称为小端
* ==高==字节存储在内存==起始地址==，称为大端

例如：
对于一个 32 位 int 型整数 0x12345678
MSB（最高位有效）为 0x12，LSB（最低位有效）为 0x78

在内存中两种存储方式：

```
（低地址）                     （高地址）
-------------内存增大方向------------>
0x12(MSB)    0x34    0x56    0x78(LSB)      <-大端
0x78(LSB)    0x56    0x34    0x12(MSB)      <-小端

（高地址）                     （低地址）
<-------------内存增大方向------------
0x78(LSB)    0x56    0x34    0x12(MSB)      <-大端
0x12(MSB)    0x34    0x56    0x78(LSB)      <-小端

```

大端比较符合我们的书写过程，从左到右先写高位
![Pasted image 20230522002351](https://raw.githubusercontent.com/24849748/PicBed/main/ob/202306091022693.png)

计算机先处理低位字节效率较高，所以均采用小端模式
对于字节内部的每位，都是按照人类习惯从左到右存放

有一片内存地址：
| 地址 | 数据 |
| --- | --- |
| ... | ... |
|0x0000|0x12|
|0x0001|0x34|
|0x0002|0x56|
|0x0003|0x78|

如果从 0x0000 读出 4 字节变量，
小端读出的结果是 0x78563412
大端读出的结果是 0x12345678

### 分析步骤：
1. 找数据 LSB MSB
2. LSB 在低地址/起始地址，小端
3. MSB 在低地址/起始地址，大端

### 判断大小端：

#### 1. 强制类型转换

```c
int main()
{
    int num = 1;    // 以 16 进制表示 00 00 00 01
    if(*(char *)&num == 1)    // 取该数据首地址，强转为字节类型，取 num 最低字节
    {
        printf("Little Endian\n");    // 如果是 1，LSB 在低内存，小端
    }
    else
    {
        printf("Big Endian\n");    // 否则大端
    }
    return 0;
}
```

#### 2.union 联合体

在某些平台可能不适用

利用共用体的特点：a b 都是从共用体的低地址开始存放的
假如 u1 所在 4 字节地址是 0 1 2 3
那么 a 就是
```c
typedef union
{
    int a;
    char b;
}Endian;

int judge_endian(void)
{
    Endian u;
    u.a = 0x12345678;
    if(u.b == 0x78)
    {
        printf("little endian\n");
        return 1;
    }
    else if(u.b == 0x12)
    {
        printf("big endian\n");
        return 0;
    }
}
```

### 大小端应用：
大端：
* C51
* PNG 图片
* TCP/IP
* Linux 系统
因为符号位在 MSB，可以快速判断大小
有利于网络传输

小端：
* ARM
* Android
因为小端模式类型强转时不需要调整字节内容，可以直接截取低字节
CPU 运算效率高，方便位运算和字节对齐