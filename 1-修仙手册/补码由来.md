
补码作用：将减法转成加法，最高位为符号位，**0正1负**

* 正数的补码等于原码
    * 如5 `0101` 的补码为 `0101` 
* 负数的补码等于反码+1
    * 如求 -2 的补码
        * 转为原码等于 `1010`
        * 符号位不变，其余按位取反得 `1101`
        * +1得补码 `1110`
* 

”负数的补码等于反码+1“ 只是补码的求法，不是定义、
补码的思想来源于**时钟、经纬度**
比如，时钟中，8+2=10 与 8-10=10 结果都一样
因为最终结果都一样，所以8-10就可以转换成8+2来运算

2的由来：==模-10==
这里模就是12点

![Pasted image 20230523102907](https://raw.githubusercontent.com/24849748/PicBed/main/ob/202306091022192.png)


举例：`5-2`
1. 2（010）的补码（101 + 1）就是-2（110）  //  补码为反码+1，110就是6
2. 那么 `5-2` 就变成 `5+6` ，也就是 `5+(8-2)`
3. 计算机只看这三位，所以最终结果就是 3（101 + 110 = 011）

这里8是模，那么模8是怎么来的？

1. 我们知道，原码 + 反码 = 最大值全1 `010 + 101 = 111` 
2. 那么如果要求反码，就可以用最大值-原码 `111 - 010`
3. 而补码又是反码+1 `111 - 010 + 1`
4. 变换一下 `111 + 1 - 010`
5. `111 + 1` 就是8，所以就是8 - 2

模等于最大值+1，如：
时钟上显示的最大数是11点，模就是12点
3bit的数，模是111+1；5bit的模是11111+1









